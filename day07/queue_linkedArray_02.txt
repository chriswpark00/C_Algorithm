#include <stdio.h>
#include <stdlib.h>
/*
queue 배열로 구현 
1. 배열은 데이터 개수가 제한적이다.
1-2 번거롭다. 한정적이다. -> 단점  
2. 배열로 구현하면 코더가 편함.... -> 장점? 

queue 연결리스트로 구현
1. 연결리스트로 구현시 메모리가 허용하는 만큼 데이터 할당 가능!
2. 데이터 정보도 한정적이지 않음  (구조체 이용하기 때문에 여러타입의 데이터를 담을 수 있음)
*/
typedef struct NODE{

	int data;
	struct NODE *next;
	
}node;

typedef struct Queue{
	node * front; // 처음을 기억
	node * rear;  // 끝을 기억 // next 개념과 비슷..? 추가되는 노드를 따라감 ..? 가리킴  
	int size;
}que;

void Enqueue(que *q, int data){ // queue의 주소값을 받기위해 que * 타입사용 
	node * n = (node *)malloc(sizeof(node)); 
	n->data=data;
	n->next=NULL;
	if(q->size==0){ // 큐가 비어있었다. front를 현재노드로 설정!!
		q->front = n; 
	} else {
		q->rear->next=n; // 22번라인 수행전에 노드연결하기!! 
	}
	q->rear=n;
	q->size++;
}

int Dequeue(que * q){ 
	int result = q->front->data; // que 는 FIFO 개념 ! 먼저 들어왔던 데이터를 리턴후 삭제 or 쓰레기값으로 변경
	node * p = q->front; // 삭제할 데이터의 주소를 기억
	q->front = p->next;  
	free(p); // 삭제 !
	q->size--; // 데이터 삭제한 만큼 배열의 길이 감소 
	return result; 
}

void show( que * q){
	node * p = q->front;
	while(p!=NULL){
		printf("%d ", p->data);
		p=p->next;
	}
}

int main() {
	
	que q;
	q.front = NULL;
	q.rear = NULL;
	q.size = 0;
	
	int act; 
	while(1){
	
		printf("1.삽입 2.삭제 3.크기 4.출력 5.종료 ");
		scanf("%d", &act);
		
		if (act == 5) break;
		
		switch(act){
		
		case 1:
			printf("정수입력:" ); // 연결리스트여서 index제한이 없다 ! (완벽한 동적배열?)
			int data;
			scanf("%d",&data);
			Enqueue(&q, data); // call by pointer개념? 사용하기위해 주소를 보냄 
			break;
		case 2:
			if(q.size==0){
				printf("텅빔\n");
				continue;
			}
			printf("Dequeue(): %d\n",Dequeue(&q)); // 현재 q는 전역변수가 아니기 때문에 주소값으로 보냄 
			break;
		case 3:
			printf("size = &d\n", q.size); 
			break;
		case 4:
			if(q.size==0){
				printf("텅빔\n");
				continue;
			}
			printf("show():");
			show(&q);
			printf("\n");
			break;
		}
	}
	return 0;
}